generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

model User {
  id                     String           @id @default(uuid())
  email                  String           @unique
  password               String
  displayName            String
  picture                String?
  isVerified             Boolean          @default(false) @map("is_verified")
  isTwoFactorEnabled     Boolean          @default(false) @map("is_two_factor_enabled")
  method                 AuthMethod
  role                   UserRole         @default(REGULAR)
  createdAt              DateTime         @default(now()) @map("created_at")
  updatedAt              DateTime         @updatedAt @map("updated_at")
  accounts               Account[]
  debtPayments           DebtPayment[]    @relation("DebtPayer")
  credits                Debt[]           @relation("Creditor")
  debts                  Debt[]           @relation("Debtor")
  expensesPaid           ExpensePayment[] @relation("ExpensePayer")
  expensesCreated        Expense[]        @relation("ExpenseCreator")
  receivedFriendRequests FriendRequests[] @relation("ReceivedFriendRequests")
  sentFriendRequests     FriendRequests[] @relation("SentFriendRequests")
  groupMemberships       GroupMember[]
  notifications          Notification[]

  @@map("users")
}

model Account {
  id           String   @id @default(uuid())
  userEmail    String   @unique
  userId       String?  @map("user_id")
  provider     String
  type         String
  refreshToken String?  @map("refresh_token")
  accessToken  String?  @map("access_token")
  expiresAt    Int?     @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  user         User?    @relation(fields: [userId], references: [id])

  @@map("accounts")
}

model Token {
  id        String    @id @default(uuid())
  email     String
  token     String    @unique
  type      TokenType
  expiresIn DateTime  @map("expires_in")
  createdAt DateTime  @default(now()) @map("created_at")

  @@map("tokens")
}

model FriendRequests {
  id         String       @id @default(cuid())
  senderId   String       @map("sender_id")
  receiverId String       @map("receiver_id")
  status     FriendStatus
  createdAt  DateTime     @default(now()) @map("created_at")
  updatedAt  DateTime     @updatedAt @map("updated_at")
  receiver   User         @relation("ReceivedFriendRequests", fields: [receiverId], references: [id])
  sender     User         @relation("SentFriendRequests", fields: [senderId], references: [id])

  @@map("friend_requests")
}

model GroupEntity {
  id         String        @id @default(uuid())
  name       String
  avatarUrl  String?       @map("avatar_url")
  isLocked   Boolean       @default(false) @map("is_locked")
  isFinished Boolean       @default(false) @map("is_finished")
  eventDate  DateTime      @default(now()) @map("date")
  createdAt  DateTime      @default(now()) @map("created_at")
  updatedAt  DateTime      @updatedAt @map("updated_at")
  isPersonal Boolean       @default(false) @map("is_personal")
  expenses   Expense[]
  members    GroupMember[]

  @@map("groups")
}

model GroupMember {
  userId   String            @map("user_id")
  groupId  String            @map("group_id")
  role     GroupRole         @default(MEMBER)
  status   GroupMemberStatus @default(PENDING)
  joinedAt DateTime          @default(now()) @map("joined_at")
  group    GroupEntity       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, groupId])
  @@map("group_members")
}

model Expense {
  id          String           @id @default(uuid())
  groupId     String           @map("group_id")
  creatorId   String           @map("creator_id")
  amount      Float
  description String
  photoUrl    String?          @map("photo_url")
  splitType   SplitType        @default(EQUAL) @map("split_type")
  date        DateTime         @default(now()) @map("date")
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")
  formData    Json?            @map("form_data")
  splits      Debt[]           @relation("ExpenseDebts")
  payers      ExpensePayment[] @relation("ExpensePayments")
  creator     User             @relation("ExpenseCreator", fields: [creatorId], references: [id])
  group       GroupEntity      @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("expenses")
}

model ExpensePayment {
  id        String   @id @default(uuid())
  expenseId String   @map("expense_id")
  payerId   String   @map("payer_id")
  amount    Float
  createdAt DateTime @default(now()) @map("created_at")
  expense   Expense  @relation("ExpensePayments", fields: [expenseId], references: [id], onDelete: Cascade)
  payer     User     @relation("ExpensePayer", fields: [payerId], references: [id])

  @@map("expense_payments")
}

model Debt {
  id          String        @id @default(uuid())
  expenseId   String        @map("expense_id")
  debtorId    String        @map("debtor_id")
  creditorId  String        @map("creditor_id")
  amount      Float
  remaining   Float
  percentage  Float?        @map("percentage")
  shares      Int?          @map("shares")
  extraAmount Float?        @map("extra_amount")
  status      DebtStatus    @default(PENDING)
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")
  isActual    Boolean       @default(true) @map("is_actual")
  payments    DebtPayment[] @relation("DebtPayments")
  creditor    User          @relation("Creditor", fields: [creditorId], references: [id])
  debtor      User          @relation("Debtor", fields: [debtorId], references: [id])
  expense     Expense       @relation("ExpenseDebts", fields: [expenseId], references: [id], onDelete: Cascade)

  @@index([expenseId])
  @@map("debts")
}

model DebtPayment {
  id        String   @id @default(uuid())
  debtId    String   @map("debt_id")
  amount    Float
  createdAt DateTime @default(now()) @map("created_at")
  isActual  Boolean  @default(true) @map("is_actual")
  creatorId String   @map("creator_id")
  creator   User     @relation("DebtPayer", fields: [creatorId], references: [id], onDelete: Cascade)
  debt      Debt     @relation("DebtPayments", fields: [debtId], references: [id], onDelete: Cascade)

  @@index([debtId])
  @@map("debt_payments")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String
  message   String
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")

  // Деталі для різних типів нотифікацій
  relatedUserId    String? @map("related_user_id") // ID користувача (для friend request)
  relatedGroupId   String? @map("related_group_id") // ID групи (для group invitation)
  relatedExpenseId String? @map("related_expense_id") // ID витрати (для expense notification)
  relatedDebtId    String? @map("related_debt_id") // ID боргу (для debt notification)

  // Додаткові дані
  metadata Json? // Для зберігання додаткової інформації

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@map("notifications")
}

enum UserRole {
  REGULAR
  ADMIN
}

enum AuthMethod {
  CREDENTIALS
  GOOGLE
}

enum TokenType {
  VERIFIFCATION
  TWO_FACTOR
  PASSWORD_RESET
}

enum FriendStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum GroupRole {
  ADMIN
  MEMBER
}

enum GroupMemberStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum DebtStatus {
  PENDING
  SETTLED
}

enum SplitType {
  EQUAL
  CUSTOM
  PERCENTAGE
  SHARES
  EXTRA
}

enum NotificationType {
  FRIEND_REQUEST //yes
  GROUP_INVITATION //yes
  EXPENSE_ADDED //yes
  DEBT_CREATED //yes
  DEBT_SETTLED //yes
  USER_REMOVED_FROM_GROUP //yes
}
